/* eslint-disable */
// @ts-nocheck
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async fetchPatreonData() : Promise<Result<PatreonData, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_patreon_data") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchPatreonVrchatNames() : Promise<Result<PatreonVRChatNames, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_patreon_vrchat_names") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchBlacklist() : Promise<Result<WorldBlacklist, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_blacklist") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getChangelog() : Promise<Result<LocalizedChanges[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_changelog") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTaskStatus(id: string) : Promise<Result<TaskStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_task_status", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelTaskRequest(id: string) : Promise<Result<TaskStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_task_request", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTaskError(id: string) : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_task_error", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkForUpdate() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_for_update") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async downloadUpdate() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_update") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async installUpdate() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("install_update") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async doNotNotifyUpdate() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("do_not_notify_update") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addWorldToFolder(folderName: string, worldId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_world_to_folder", { folderName, worldId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addWorldsToFolder(folderName: string, worldIds: string[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_worlds_to_folder", { folderName, worldIds }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeWorldFromFolder(folderName: string, worldId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_world_from_folder", { folderName, worldId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hideWorld(worldId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("hide_world", { worldId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async unhideWorld(worldId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unhide_world", { worldId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getFolders() : Promise<Result<FolderData[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_folders") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createFolder(name: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_folder", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteFolder(name: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_folder", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async moveFolder(folderName: string, newIndex: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("move_folder", { folderName, newIndex }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async renameFolder(oldName: string, newName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("rename_folder", { oldName, newName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setFolderColor(folderName: string, color: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_folder_color", { folderName, color }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getWorlds(folderName: string) : Promise<Result<WorldDisplayData[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_worlds", { folderName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAllWorlds() : Promise<Result<WorldDisplayData[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_worlds") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getUnclassifiedWorlds() : Promise<Result<WorldDisplayData[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_unclassified_worlds") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getHiddenWorlds() : Promise<Result<WorldDisplayData[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_hidden_worlds") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTagsByCount() : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_tags_by_count") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAuthorsByCount() : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_authors_by_count") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteWorld(worldId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_world", { worldId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getFoldersForWorld(worldId: string) : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_folders_for_world", { worldId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async shareFolder(folderName: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("share_folder", { folderName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateFolderShare(folderName: string) : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_folder_share", { folderName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Downloads a shared folder and adds its worlds to the local database.
 * 
 * This function attempts to download a folder using the provided `share_id`, creates the folder locally,
 * adds the worlds from the shared folder to the local world list, and then adds all non-hidden worlds to the new folder.
 * Worlds that are already hidden are not added to the folder and are returned for further handling.
 * 
 * # Arguments
 * 
 * * `share_id` - The identifier of the shared folder to download.
 * 
 * # Returns
 * 
 * `Ok((String, Vec<String>))`: A tuple containing the new folder name and a vector of world IDs that were hidden and not added to the folder.
 * 
 * # Errors
 * Returns an error string if any operation fails, such as downloading the folder, creating the folder, adding worlds, or retrieving hidden worlds.
 */
async downloadFolder(shareId: string) : Promise<Result<[string, WorldDisplayData[]], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_folder", { shareId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTheme() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_theme") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setTheme(theme: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_theme", { theme }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getLanguage() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_language") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setLanguage(language: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_language", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCardSize() : Promise<Result<CardSize, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_card_size") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setCardSize(cardSize: CardSize) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_card_size", { cardSize }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRegion() : Promise<Result<InstanceRegion, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_region") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setRegion(region: InstanceRegion) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_region", { region }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getStarredFilterItems(id: FilterItemSelectorStarredType) : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_starred_filter_items", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setStarredFilterItems(id: FilterItemSelectorStarredType, values: string[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_starred_filter_items", { id, values }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getFolderRemovalPreference() : Promise<Result<FolderRemovalPreference, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_folder_removal_preference") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setFolderRemovalPreference(dontShowRemoveFromFolder: FolderRemovalPreference) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_folder_removal_preference", { dontShowRemoveFromFolder }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getUpdateChannel() : Promise<Result<UpdateChannel, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_update_channel") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setUpdateChannel(channel: UpdateChannel) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_update_channel", { channel }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSortPreferences() : Promise<Result<[string, string], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_sort_preferences") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSortPreferences(sortField: string, sortDirection: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_sort_preferences", { sortField, sortDirection }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDefaultInstanceType() : Promise<Result<DefaultInstanceType, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_default_instance_type") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setDefaultInstanceType(instanceType: DefaultInstanceType) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_default_instance_type", { instanceType }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getVisibleButtons() : Promise<Result<VisibleButtons, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_visible_buttons") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setVisibleButtons(visibleButtons: VisibleButtons) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_visible_buttons", { visibleButtons }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async tryLogin() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("try_login") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async loginWithCredentials(username: string, password: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("login_with_credentials", { username, password }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async loginWith2fa(code: string, twoFactorType: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("login_with_2fa", { code, twoFactorType }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async logout() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("logout") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getFavoriteWorlds() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_favorite_worlds") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getWorld(worldId: string, dontSaveToLocal: boolean | null) : Promise<Result<WorldDetails, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_world", { worldId, dontSaveToLocal }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkWorldInfo(worldId: string) : Promise<Result<WorldDetails, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_world_info", { worldId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecentlyVisitedWorlds() : Promise<Result<WorldDisplayData[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recently_visited_worlds") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async searchWorlds(sort: string, tags: string[], excludeTags: string[], search: string, page: number) : Promise<Result<WorldDisplayData[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_worlds", { sort, tags, excludeTags, search, page }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createWorldInstance(worldId: string, instanceTypeStr: string, regionStr: string) : Promise<Result<InstanceInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_world_instance", { worldId, instanceTypeStr, regionStr }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getUserGroups() : Promise<Result<UserGroup[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_user_groups") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getPermissionForCreateGroupInstance(groupId: string) : Promise<Result<GroupInstancePermissionInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_permission_for_create_group_instance", { groupId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createGroupInstance(worldId: string, groupId: string, instanceTypeStr: string, allowedRoles: string[] | null, regionStr: string, queueEnabled: boolean) : Promise<Result<InstanceInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_group_instance", { worldId, groupId, instanceTypeStr, allowedRoles, regionStr, queueEnabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openInstanceInClient(worldId: string, instanceId: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_instance_in_client", { worldId, instanceId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openLogsDirectory() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_logs_directory") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openFolderDirectory() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_folder_directory") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks if the app is being run for the first time
 * As this is called every time / is loaded from the frontend, cache result in the state
 */
async requireInitialSetup() : Promise<boolean> {
    return await TAURI_INVOKE("require_initial_setup");
},
/**
 * Checks if files have been loaded from disk successfully
 * 
 * # Returns
 * Returns a boolean indicating if the files have been loaded successfully
 * 
 * # Errors
 * Returns a tuple containing a boolean indicating if the files have been loaded, and an error message
 */
async checkFilesLoaded() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_files_loaded") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async detectOldInstallation() : Promise<Result<[string, string], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("detect_old_installation") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Passes the paths to the frontend
 * Gets the path to the local app data directory
 * 
 * # Returns
 * Returns the path to the local app data directory
 * 
 * # Errors
 * Returns an error message if the path to the local app data directory could not be found
 */
async passPaths() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pass_paths") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkExistingData() : Promise<Result<[boolean, boolean], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_existing_data") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getBackupMetadata(backupPath: string) : Promise<Result<BackupMetaData, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_backup_metadata", { backupPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getMigrationMetadata(worldsPath: string, foldersPath: string) : Promise<Result<PreviousMetadata, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_migration_metadata", { worldsPath, foldersPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createEmptyAuth() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_empty_auth") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createEmptyFiles() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_empty_files") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createBackup(backupPath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_backup", { backupPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async restoreFromBackup(backupPath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("restore_from_backup", { backupPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async exportToPortalLibrarySystem(folders: string[], sortField: string, sortDirection: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_to_portal_library_system", { folders, sortField, sortDirection }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async migrateOldData(worldsPath: string, foldersPath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("migrate_old_data", { worldsPath, foldersPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteData() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_data") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async exportNativeData(path: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_native_data", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getMemo(worldId: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_memo", { worldId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setMemoAndSave(worldId: string, memo: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_memo_and_save", { worldId, memo }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async searchMemoText(searchText: string) : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_memo_text", { searchText }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setWorldPhotographed(worldId: string, isPhotographed: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_world_photographed", { worldId, isPhotographed }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setWorldShared(worldId: string, isShared: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_world_shared", { worldId, isShared }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setWorldFavorite(worldId: string, isFavorite: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_world_favorite", { worldId, isFavorite }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async sortWorldsDisplay(worlds: WorldDisplayData[], sortField: string, sortDirection: string) : Promise<Result<WorldDisplayData[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("sort_worlds_display", { worlds, sortField, sortDirection }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resolveRedirects(url: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resolve_redirects", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getStartupDeepLink() : Promise<string | null> {
    return await TAURI_INVOKE("get_startup_deep_link");
}
}

/** user-defined events **/


export const events = __makeEvents__<{
taskStatusChanged: TaskStatusChanged
}>({
taskStatusChanged: "task-status-changed"
})

/** user-defined constants **/



/** user-defined types **/

export type BackupMetaData = { date: string; number_of_folders: number; number_of_worlds: number; app_version: string }
export type CardSize = "Compact" | "Normal" | "Expanded" | "Original"
export type DefaultInstanceType = "public" | "group" | "friends+" | "friends" | "invite+" | "invite"
export type FilterItemSelectorStarredType = "Author" | "Tag" | "ExcludeTag" | "Folder"
export type FolderData = { name: string; world_count: number; color: string | null }
export type FolderRemovalPreference = "ask" | "alwaysRemove" | "neverRemove"
export type GroupInstanceCreateAllowedType = { normal: boolean; plus: boolean; public: boolean; restricted: boolean }
export type GroupInstanceCreatePermission = { Allowed: GroupInstanceCreateAllowedType } | "NotAllowed"
export type GroupInstancePermissionInfo = { permission: GroupInstanceCreatePermission; roles: GroupRole[] }
export type GroupMemberVisibility = "visible" | "friends" | "hidden"
export type GroupPermission = "*" | "group-announcement-manage" | "group-audit-view" | "group-bans-manage" | "group-data-manage" | "group-default-role-manage" | "group-galleries-manage" | "group-instance-age-gated-create" | "group-instance-join" | "group-instance-manage" | "group-instance-moderate" | "group-instance-open-create" | "group-instance-plus-create" | "group-instance-plus-portal" | "group-instance-plus-portal-unlocked" | "group-instance-public-create" | "group-instance-queue-priority" | "group-instance-restricted-create" | "group-invites-manage" | "group-members-manage" | "group-members-remove" | "group-members-viewall" | "group-roles-assign" | "group-roles-manage"
export type GroupRole = { id: string; groupId: string; name: string; permissions: GroupPermission[]; isManagementRole: boolean }
export type InstanceInfo = { world_id: string; instance_id: string; short_name: string | null }
export type InstanceRegion = "us" | "use" | "eu" | "jp"
export type LocalizedChanges = { version: string; pre_release: boolean; features: string[]; fixes: string[]; others: string[] }
export type PatreonData = { platinumSupporter: string[]; goldSupporter: string[]; silverSupporter: string[]; bronzeSupporter: string[]; basicSupporter: string[] }
export type PatreonVRChatNames = { platinumSupporter: string[]; goldSupporter: string[]; silverSupporter: string[]; bronzeSupporter: string[]; basicSupporter: string[] }
export type Platform = "PC" | "Quest" | "Cross-Platform"
export type PreviousMetadata = { number_of_folders: number; number_of_worlds: number }
export type TaskStatus = "Running" | "Completed" | "Cancelled" | "Failed"
export type TaskStatusChanged = { id: string; status: TaskStatus }
export type UpdateChannel = "stable" | "pre-release"
export type UserGroup = { id: string; name: string; shortCode: string; discriminator: string; description: string; iconUrl?: string | null; bannerUrl?: string | null; privacy: string; memberCount: number; groupId: string; memberVisibility: GroupMemberVisibility; isRepresenting: boolean; mutualGroup: boolean }
export type VisibleButtons = { favorite: boolean; photographed: boolean; shared: boolean }
export type WorldBlacklist = { worlds: string[] }
export type WorldDetails = { worldId: string; name: string; thumbnailUrl: string; authorName: string; authorId: string; favorites: number; lastUpdated: string; visits: number; platform: Platform; description: string; tags: string[]; capacity: number; recommendedCapacity: number | null; publicationDate: string | null }
export type WorldDisplayData = { worldId: string; name: string; thumbnailUrl: string; authorName: string; favorites: number; lastUpdated: string; visits: number; dateAdded: string; platform: Platform; folders: string[]; tags: string[]; capacity: number; isPhotographed: boolean; isShared: boolean; isFavorite: boolean }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
